---
alwaysApply: true
---

Cursor ルール — React + TypeScript + shadcn/ui（Next.js なし）

おしゃれで一貫性のある UI を React + TypeScript + shadcn/ui + Tailwind CSS で実装するためのガイドライン。
（Vite などの一般的なビルド環境を想定。ルーティングは React Router を推奨）

目的

shadcn/ui を基礎に、上品・最小限・再利用可能な UI を素早く構築

ダークモード・アクセシビリティ・国際化・パフォーマンスをデフォルトで担保

一貫した Design Token と Variant パターン を徹底

原則（Must / Should）

shadcn/ui を最優先

UI は @/components/ui/\* を基本。カスタムはラップして拡張。

アイコンは lucide-react を利用。

型安全（TypeScript）

any 禁止。Props と戻り値に明示型。

デザイントークン徹底

任意の hex / rgb 直書き禁止。--primary など CSS 変数／Tailwind Theme 経由。

アクセシビリティ

すべてのインタラクティブ要素に フォーカスリング。フォームにラベルとエラー表示。

コントラスト比 4.5:1 以上目標。

ダークモード必須

document.documentElement.classList.toggle("dark") で切替。どのテーマでも読みやすく。

レイアウト/余白の一貫性

コンテナ max-w-7xl、gap-6、p-6 を基準。角丸は rounded-2xl。

モーションは控えめに

framer-motion は小さめ（フェード＋微小移動、hover は scale-105 未満）。

状態設計の標準化

Loading / Empty / Error を必ず実装。データ取得は React Query 推奨。

フォームは RHF + zod

react-hook-form + zod と shadcn/ui のフォームラッパー。

国際化 (i18n)

文言は辞書管理（例: react-intl, i18next）。ハードコード禁止。

パフォーマンス

画像は <img loading="lazy" /> やライブラリで遅延読込。コード分割/メモ化で再レンダー抑制。

テスト

@testing-library/react + vitest（または jest）。アクセシブルクエリ（getByRole）優先。

命名/コミット規約

PascalCase（コンポーネント）、kebab-case（ディレクトリ）、camelCase（変数）。

Conventional Commits（feat(ui): ..., fix(ui): ... など）。

推奨ディレクトリ
src/
main.tsx # エントリ
app/
router.tsx # React Router 設定
components/
ui/ # shadcn/ui 基礎
primitives/ # 小さめのラッパー
features/ # 機能単位の複合コンポーネント
states/ # Skeleton / Empty / Error
lib/ # util（cn, fetcher 等）
styles/ # tokens / globals.css

パスエイリアス @/\* は tsconfig.json と bundler（Vite/webpack）で一致させる。

Design Tokens（例）
src/styles/globals.css（抜粋）
:root {
--background: 0 0% 100%;
--foreground: 222.2 84% 4.9%;

--primary: 222.2 47.4% 11.2%;
--primary-foreground: 210 40% 98%;

--secondary: 210 40% 96.1%;
--secondary-foreground: 222.2 47.4% 11.2%;
}

.dark {
--background: 222.2 84% 4.9%;
--foreground: 210 40% 98%;

--primary: 210 40% 98%;
--primary-foreground: 222.2 47.4% 11.2%;

--secondary: 217.2 32.6% 17.5%;
--secondary-foreground: 210 40% 98%;
}

tailwind.config.ts（抜粋）
import type { Config } from "tailwindcss";

export default {
darkMode: ["class"],
content: ["./index.html", "./src/**/*.{ts,tsx}"],
theme: {
extend: {
borderRadius: {
xl: "0.75rem",
"2xl": "1rem",
},
maxWidth: {
container: "80rem", // ≒ 1280px
"7xl": "80rem",
},
},
},
plugins: [],
} satisfies Config;

ユーティリティ
src/lib/utils.ts
import { type ClassValue } from "clsx";
import clsx from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
return twMerge(clsx(inputs));
}

エントリ & ルーター（Next.js なし）
src/main.tsx
import React from "react";
import ReactDOM from "react-dom/client";
import { BrowserRouter } from "react-router-dom";
import App from "./app/router";
import "./styles/globals.css";

ReactDOM.createRoot(document.getElementById("root")!).render(
<React.StrictMode>
<BrowserRouter>
<App />
</BrowserRouter>
</React.StrictMode>
);

src/app/router.tsx
import { Routes, Route, Link } from "react-router-dom";
import { ThemeToggle } from "@/components/primitives/theme-toggle";

export default function App() {
return (
<div className="mx-auto max-w-7xl px-4 md:px-6">
<header className="flex items-center justify-between py-4">
<Link to="/" className="text-lg font-semibold">MyApp</Link>
<nav className="flex items-center gap-3">
<Link to="/" className="text-sm text-muted-foreground hover:underline">Home</Link>
<Link to="/reports" className="text-sm text-muted-foreground hover:underline">Reports</Link>
<ThemeToggle />
</nav>
</header>

      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/reports" element={<Reports />} />
      </Routes>
    </div>

);
}

function Home() {
return <section className="py-10 md:py-14">Home</section>;
}
function Reports() {
return <section className="py-10 md:py-14">Reports</section>;
}

テーマ切替（.dark を html 要素に付与）
export function ThemeToggle() {
const toggle = () => {
const el = document.documentElement;
el.classList.toggle("dark");
localStorage.setItem("theme", el.classList.contains("dark") ? "dark" : "light");
};

// 初期読込時（App 初期化で一度呼ぶなど）
// const saved = localStorage.getItem("theme");
// if (saved) document.documentElement.classList.toggle("dark", saved === "dark");

return (
<button
      onClick={toggle}
      className="rounded-2xl border px-3 py-2 text-sm hover:bg-accent focus-visible:outline-none focus-visible:ring-2"
    >
Theme
</button>
);
}

コンポーネント・スニペット（TypeScript/TSX）
Button（Variant パターン）
import \* as React from "react";
import { cva, type VariantProps } from "class-variance-authority";
import { cn } from "@/lib/utils";

const buttonVariants = cva(
"inline-flex items-center justify-center rounded-2xl text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none gap-2",
{
variants: {
variant: {
default: "bg-primary text-primary-foreground shadow hover:opacity-95",
outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
ghost: "hover:bg-accent hover:text-accent-foreground",
destructive: "bg-destructive text-destructive-foreground hover:opacity-95",
},
size: {
sm: "h-9 px-3",
md: "h-10 px-4",
lg: "h-11 px-6",
},
},
defaultVariants: { variant: "default", size: "md" },
}
);

export interface ButtonProps
extends React.ButtonHTMLAttributes<HTMLButtonElement>,
VariantProps<typeof buttonVariants> {}

export const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
({ className, variant, size, ...props }, ref) => (
<button
ref={ref}
className={cn(buttonVariants({ variant, size }), className)}
{...props}
/>
)
);
Button.displayName = "Button";

export { buttonVariants };

Panel（カードの基準）
import \* as React from "react";
import { cn } from "@/lib/utils";

type Props = {
title: string;
description?: string;
action?: React.ReactNode;
children: React.ReactNode;
className?: string;
};

export function Panel({ title, description, action, children, className }: Props) {
return (
<section className={cn("rounded-2xl border bg-card text-card-foreground shadow-sm", className)}>
<header className="flex items-start justify-between gap-4 p-6">
<div>
<h2 className="text-lg font-semibold leading-tight">{title}</h2>
{description && <p className="mt-1 text-sm text-muted-foreground">{description}</p>}
</div>
{action}
</header>
<div className="p-6 pt-0">{children}</div>
</section>
);
}

状態表示（Loading / Empty / Error）
import { AlertCircle, Inbox } from "lucide-react";
import { Skeleton } from "@/components/ui/skeleton";

export const LoadingList = () => (

  <div className="space-y-3">
    {Array.from({ length: 6 }).map((_, i) => (
      <Skeleton key={i} className="h-10 w-full" />
    ))}
  </div>
);

export function EmptyState({
title = "データがありません",
action,
}: { title?: string; action?: React.ReactNode }) {
return (
<div className="rounded-2xl border p-10 text-center text-muted-foreground">
<Inbox className="mx-auto h-8 w-8" aria-hidden />
<p className="mt-3 text-sm">{title}</p>
{action && <div className="mt-4">{action}</div>}
</div>
);
}

export function ErrorState({ message = "エラーが発生しました" }: { message?: string }) {
return (
<div role="alert" className="rounded-2xl border p-6 text-destructive-foreground">
<div className="flex items-center gap-2">
<AlertCircle className="h-5 w-5" aria-hidden />
<p className="font-medium">{message}</p>
</div>
</div>
);
}

フォーム（react-hook-form + zod + shadcn/ui）
import { z } from "zod";
import { zodResolver } from "@hookform/resolvers/zod";
import { useForm } from "react-hook-form";
import { Form, FormField, FormItem, FormLabel, FormControl, FormMessage } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";

const schema = z.object({
name: z.string().min(1, "必須です"),
email: z.string().email("メール形式が不正です"),
});
type Schema = z.infer<typeof schema>;

export function ProfileForm() {
const form = useForm<Schema>({
resolver: zodResolver(schema),
defaultValues: { name: "", email: "" },
});

const onSubmit = form.handleSubmit(async (values) => {
console.log(values); // TODO: API 呼び出し
});

return (
<Form {...form}>
<form onSubmit={onSubmit} className="space-y-6">
<FormField
control={form.control}
name="name"
render={({ field }) => (
<FormItem>
<FormLabel>名前</FormLabel>
<FormControl>
<Input placeholder="山田 太郎" {...field} />
</FormControl>
<FormMessage />
</FormItem>
)}
/>
<FormField
control={form.control}
name="email"
render={({ field }) => (
<FormItem>
<FormLabel>メール</FormLabel>
<FormControl>
<Input type="email" placeholder="taro@example.com" {...field} />
</FormControl>
<FormMessage />
</FormItem>
)}
/>
<Button type="submit">保存</Button>
</form>
</Form>
);
}

チェックリスト（PR 前）

shadcn/ui + Design Token のみで色・影を構成（任意色直書きなし）

ライト/ダーク両方の視認性（≥ 4.5:1）

Loading / Empty / Error 実装済み

RHF + zod でフォーム検証

フォーカスリング/aria-\*/role 整備

主要ブレークポイントで崩れなし（モバイルファースト）

コンポーネントの使用例 or Story/MDX 付属

命名規約・Conventional Commits 準拠

@testing-library/react で主要フローのテスト
